import{cP as K,cQ as j,cw as z,cR as B,aO as y}from"./index-C1aGfQcb.js";import{i as L}from"./saveAPIKeyUtils-BWiJCGqJ.js";import{$ as Q,w as N,I as x,j as V,y as k,P as q,l as O,d as C,v as g,c as A}from"./utils-BI31Ke1l.js";import{d as m}from"./arcgisLayerUrl-BkZy4Mr3.js";import{t as H,a as W,i as X}from"./fetchService-DODjWwEX.js";import{l as R,a as T,u as d,f as u,i as Z}from"./portalItemUtils-Cy9KvMYK.js";import"./multiOriginJSONSupportUtils-C0wm8_Yw.js";import"./jsonContext-DJAfzMqt.js";import"./saveUtils-DXB-y_0Z.js";import"./projection-BOBOhWzm.js";import"./projectBuffer-CZ7yaGuo.js";const w="Feature Service",v="feature-layer-utils",aa=`${v}-save`,ea=`${v}-save-as`,p=`${v}-saveall`,f=`${v}-saveall-as`;function $(a){return{isValid:B(a)&&(!("dynamicDataSource"in a)||!a.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function M(a){const e=[],t=[];for(const{layer:r,layerJSON:s}of a)r.isTable?t.push(s):e.push(s);return{layers:e,tables:t}}function D(a){return M([a])}async function J(a,e){return/\/\d+\/?$/.test(a.url)?D(e[0]):F(e,a)}async function F(a,e){if(a.reverse(),!e)return M(a);const t=await ta(e,a);for(const r of a)U(r.layer,r.layerJSON,t);return oa(t,a),t}async function ta(a,e){let t=await a.fetchData("json");if(ra(t))return t;t||(t={}),na(t);const{layer:{url:r,customParameters:s,apiKey:o}}=e[0];return await sa(t,{url:r??"",customParameters:s,apiKey:o},e.map(n=>n.layer.layerId)),t}function ra(a){return!!(a&&Array.isArray(a.layers)&&Array.isArray(a.tables))}function na(a){a.layers||(a.layers=[]),a.tables||(a.tables=[])}function oa(a,e){const t=[],r=[];for(const{layer:s}of e){const{isTable:o,layerId:n}=s;o?r.push(n):t.push(n)}P(a.layers,t),P(a.tables,r)}function P(a,e){if(a.length<2)return;const t=[];for(const{id:r}of a)t.push(r);K(t.sort(b),e.slice().sort(b))&&a.sort((r,s)=>{const o=e.indexOf(r.id),n=e.indexOf(s.id);return o<n?-1:o>n?1:0})}function b(a,e){return a<e?-1:a>e?1:0}async function sa(a,e,t){const{url:r,customParameters:s,apiKey:o}=e,{serviceJSON:n,layersJSON:i}=await H(r,{customParameters:s,apiKey:o}),l=S(a.layers,n.layers,t),c=S(a.tables,n.tables,t);a.layers=l.itemResources,a.tables=c.itemResources;const h=[...l.added,...c.added],G=i?[...i.layers,...i.tables]:[];await ia(a,h,r,G)}function S(a,e,t){const r=j(a,e,(o,n)=>o.id===n.id);a=a.filter(o=>!r.removed.some(n=>n.id===o.id));const s=r.added;return s.forEach(({id:o})=>{a.push({id:o})}),{itemResources:a,added:s.filter(({id:o})=>!t.includes(o))}}async function ia(a,e,t,r){const s=await la(e),o=e.map(({id:n,type:i})=>new(s.get(i))({url:t,layerId:n,sourceJSON:r.find(({id:l})=>l===n)}));await Promise.allSettled(o.map(n=>n.load())),o.forEach(n=>{const{layerId:i,loaded:l,defaultPopupTemplate:c}=n;if(!l||c==null)return;const h={id:i,popupInfo:c.toJSON()};n.operationalLayerType!=="ArcGISFeatureLayer"&&(h.layerType=n.operationalLayerType),U(n,h,a)})}async function la(a){const e=[];a.forEach(({type:s})=>{const o=X(s),n=W[o];e.push(n())});const t=await Promise.all(e),r=new Map;return a.forEach(({type:s},o)=>{r.set(s,t[o])}),r}function U(a,e,t){a.isTable?E(t.tables,e):E(t.layers,e)}function E(a,e){const t=a.findIndex(({id:r})=>r===e.id);t===-1?a.push(e):a[t]=e}function Y(a,e){if(!a.length)throw new y(`${e}:missing-parameters`,"'layers' array should contain at least one feature layer")}function ca(a,e){const t=a.map(r=>r.portalItem.id);if(new Set(t).size>1)throw new y(`${e}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function _(a,e){const t=a.map(r=>r.layerId);if(new Set(t).size!==t.length)throw new y(`${e}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function ua(a){Y(a,p),await Promise.all(a.map(e=>e.load()));for(const e of a)O(e,p,$),C({layer:e,itemType:w,errorNamePrefix:p});ca(a,p),_(a,p)}function I(a,e){const t=a.some(r=>r.type==="oriented-imagery");d(e,u.ORIENTED_IMAGERY_LAYER,t)}async function ya(a,e){I([a],e)}async function pa(a,e){const{url:t,layerId:r,title:s,fullExtent:o,isTable:n}=a,i=m(t);e.url=((i==null?void 0:i.serverType)==="FeatureServer"?t:`${t}/${r}`)??null,e.title||(e.title=s),e.extent=null,n||o==null||(e.extent=await R(o)),T(e,u.METADATA),T(e,u.MULTI_LAYER),Z(e,u.SINGLE_LAYER),d(e,u.TABLE,n),I([a],e)}function fa(a,e){for(const o of a){const n=o.parsedUrl.path,i=m(n);if(!(i==null?void 0:i.url.path))throw new y(`${e}:invalid-parameters`,A(o,`has unsupported url pattern: ${n}`),{layer:o});const c=i==null?void 0:i.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new y(`${e}:invalid-parameters`,A(o,`has unsupported server type: ${c}`),{layer:o});if(c==="MapServer"&&a.length>1)throw new y(`${e}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=m(a[0].parsedUrl.path),r=t==null?void 0:t.url.path;if(!a.every(o=>{const n=m(o.parsedUrl.path);return(n==null?void 0:n.url.path)===r}))throw new y(`${e}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ma(a){Y(a,f),await Promise.all(a.map(e=>e.load()));for(const e of a)O(e,f,$);fa(a,f),_(a,f)}function da(a,e){I(e,a),g(a)}async function ha(a,e){let t=0,r=0;for(const{isTable:n}of e)n?r++:t++;const s=e[0].parsedUrl.path,o=m(s);if(a.url=(o==null?void 0:o.serverType)==="FeatureServer"?o.url.path:s,a.title||(a.title=o.title),a.extent=null,t>0){const n=e.map(i=>i.fullExtent).filter(z).reduce((i,l)=>i.clone().union(l));n&&(a.extent=await R(n))}T(a,u.METADATA),d(a,u.MULTI_LAYER,e.length>1),d(a,u.SINGLE_LAYER,e.length===1),d(a,u.TABLE,r>0&&t===0),I(e,a),g(a)}async function Na(a,e){return Q({layer:a,itemType:w,validateLayer:$,createItemData:(t,r)=>J(r,[t]),errorNamePrefix:aa,setItemProperties:ya},e)}async function xa(a,e){await ua(a);const t=a[0].portalItem,r=N(t),s=await Promise.all(a.map(n=>x(n,r,e))),o=await J(t,a.map((n,i)=>({layer:n,layerJSON:s[i]})));return da(t,a),await t.update({data:o}),await Promise.all(a.slice(1).map(n=>n.portalItem.reload())),L(r),t.clone()}async function Oa(a,e,t){return V({layer:a,itemType:w,validateLayer:$,createItemData:(r,s)=>Promise.resolve(D(r)),errorNamePrefix:ea,newItem:e,setItemProperties:pa},t)}async function ga(a,e,t){await ma(a);const r=k({itemType:w,errorNamePrefix:f,newItem:e}),s=N(r),o=await Promise.all(a.map(i=>x(i,s,t))),n=await F(a.map((i,l)=>({layer:i,layerJSON:o[l]})));await ha(r,a),await q(r,n,t);for(const i of a)i.portalItem=r.clone();return L(s),r}export{Na as save,xa as saveAll,ga as saveAllAs,Oa as saveAs};
