import{cx as l,bt as M,cr as P}from"./index-C1aGfQcb.js";import{o as S}from"./vec32-CmwgPQMd.js";import{a as T,b as A}from"./elevationInfoUtils-DQT3uSQq.js";import"./ElevationInfo-D7CBP7sd.js";import"./lengthUtils-CFwdZ3dz.js";function Z(e,o){const n=e==null?void 0:e.geometry;if(!e||(n==null?void 0:n.type)!=="mesh"||!o)return;const{renderCoordsHelper:c,elevationProvider:x}=o,{camera:p}=o.state,{extent:t}=n,{center:h,spatialReference:r}=t,z=l(r),s=M(r),b=l(c.spatialReference),v=t.width*z,w=t.height*s,d=(t.zmax??0)*s,f=d-(t.zmin??0)*s,y=Math.max(v,w,f)/b,{x:m,y:i}=h,u=h.z??0;S(a,m,i,u),c.toRenderCoords(a,r,a);const g=y/p.computeScreenPixelSizeAt(a);if(g>p.width*U)return"meshTooClose";if(g<H)return"meshTooFar";const C=T(e),{absoluteZ:R}=A(m,i,d,r,o,C);return R<(x.getElevation(m,i,u,r,"ground")??0)*s+f*j?"meshUnderground":"mesh"}const H=20,U=1,j=.1,a=P();export{Z as getDrawMeshHelpMessage};
